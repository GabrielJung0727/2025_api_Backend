"""
OpenAI API ÏÑúÎπÑÏä§
ÌÖçÏä§Ìä∏ Î¨∏Ï≤¥ Í∞úÏÑ† Î∞è ÌïúÍµ≠Ïñ¥ ÏµúÏ†ÅÌôîÎ•º ÏúÑÌïú OpenAI API ÌÜµÌï©
"""
import os
import logging
import asyncio
from typing import Dict, Any, Optional, List
from datetime import datetime
from dotenv import load_dotenv

try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    openai = None

# ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú
load_dotenv()

logger = logging.getLogger(__name__)

class OpenAIService:
    """OpenAI API ÏÑúÎπÑÏä§"""
    
    def __init__(self):
        self.api_key = os.getenv("OPENAI_API_KEY")
        self.model_name = os.getenv("OPENAI_MODEL_NAME", "gpt-3.5-turbo")
        self.organization = os.getenv("OPENAI_ORGANIZATION")
        
        if OPENAI_AVAILABLE and self.api_key:
            try:
                openai.api_key = self.api_key
                if self.organization:
                    openai.organization = self.organization
                
                # ÏµúÏã† Î≤ÑÏ†Ñ Ìò∏ÌôòÏÑ±
                if hasattr(openai, 'OpenAI'):
                    self.client = openai.OpenAI(
                        api_key=self.api_key,
                        organization=self.organization
                    )
                else:
                    self.client = None
                
                logger.info(f"‚úÖ OpenAI API Ï¥àÍ∏∞Ìôî ÏôÑÎ£å: {self.model_name}")
            except Exception as e:
                logger.error(f"‚ùå OpenAI API Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
                self.client = None
        else:
            self.client = None
            if not OPENAI_AVAILABLE:
                logger.warning("‚ùå OpenAI ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. 'pip install openai' Ïã§ÌñâÌïòÏÑ∏Ïöî.")
            elif not self.api_key:
                logger.warning("‚ùå OpenAI API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    
    async def improve_text_style(
        self,
        content: str,
        style_type: str = "educational",
        target_audience: str = "university_students",
        department: str = "ÏùºÎ∞òÌïôÍ≥º"
    ) -> Dict[str, Any]:
        """
        ÌÖçÏä§Ìä∏ Î¨∏Ï≤¥ Í∞úÏÑ†
        
        Args:
            content: Í∞úÏÑ†Ìï† ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©
            style_type: Î¨∏Ï≤¥ Ïú†Ìòï (educational, formal, casual, academic)
            target_audience: ÎåÄÏÉÅ ÎèÖÏûê
            department: ÌïôÍ≥º Ï†ïÎ≥¥
        """
        try:
            if not self.client and not self._is_openai_available():
                # OpenAI ÏÇ¨Ïö© Î∂àÍ∞ÄÏãú Í∏∞Î≥∏ Í∞úÏÑ† Ï≤òÎ¶¨
                return await self._fallback_text_improvement(content, style_type)
            
            logger.info(f"üîÑ OpenAI Î¨∏Ï≤¥ Í∞úÏÑ† ÏãúÏûë: {len(content)} Î¨∏Ïûê")
            
            # Î¨∏Ï≤¥ Í∞úÏÑ† ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
            improvement_prompt = self._build_improvement_prompt(
                content, style_type, target_audience, department
            )
            
            # OpenAI API Ìò∏Ï∂ú
            messages = [
                {
                    "role": "system",
                    "content": improvement_prompt["system"]
                },
                {
                    "role": "user", 
                    "content": improvement_prompt["user"]
                }
            ]
            
            response = await self._call_openai_api(messages)
            
            if not response["success"]:
                raise Exception(response["error"])
            
            improved_content = response["content"]
            
            # Í∞úÏÑ† Í≤∞Í≥º Î∂ÑÏÑù
            improvement_analysis = self._analyze_improvement(
                original=content,
                improved=improved_content,
                style_type=style_type
            )
            
            logger.info(f"‚úÖ OpenAI Î¨∏Ï≤¥ Í∞úÏÑ† ÏôÑÎ£å: {len(improved_content)} Î¨∏Ïûê")
            
            return {
                "success": True,
                "improved_content": improved_content,
                "original_content": content,
                "improvement_analysis": improvement_analysis,
                "style_type": style_type,
                "target_audience": target_audience,
                "department": department,
                "improved_at": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"‚ùå OpenAI Î¨∏Ï≤¥ Í∞úÏÑ† Ïã§Ìå®: {e}")
            # Ïã§Ìå®Ïãú ÎåÄÏ≤¥ Î∞©Î≤ï ÏÇ¨Ïö©
            return await self._fallback_text_improvement(content, style_type)
    
    def _build_improvement_prompt(
        self, 
        content: str, 
        style_type: str, 
        target_audience: str, 
        department: str
    ) -> Dict[str, str]:
        """Î¨∏Ï≤¥ Í∞úÏÑ† ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±"""
        
        style_guidelines = {
            "educational": {
                "tone": "ÏπúÍ∑ºÌïòÍ≥† Ïù¥Ìï¥ÌïòÍ∏∞ Ïâ¨Ïö¥",
                "structure": "Îã®Í≥ÑÎ≥Ñ ÏÑ§Î™Ö, ÏòàÏãú Ìè¨Ìï®",
                "language": "ÍµêÏú°Ï†ÅÏù¥Í≥† Î™ÖÌôïÌïú ÌïúÍµ≠Ïñ¥",
                "features": "ÌïôÏäµÏûê Ï§ëÏã¨, Ïã§Ïö©Ï†Å Ï†ïÎ≥¥ Í∞ïÏ°∞"
            },
            "formal": {
                "tone": "Ï†ïÏ§ëÌïòÍ≥† Í≤©ÏãùÏûàÎäî",
                "structure": "ÎÖºÎ¶¨Ï†Å ÏàúÏÑú, Ï†ïÌôïÌïú Ïö©Ïñ¥ ÏÇ¨Ïö©",
                "language": "ÌëúÏ§Ä ÌïúÍµ≠Ïñ¥, Ï°¥ÎåìÎßê",
                "features": "Í∞ùÍ¥ÄÏ†Å ÏÑúÏà†, Ï†ÑÎ¨∏ÏÑ± Í∞ïÏ°∞"
            },
            "academic": {
                "tone": "ÌïôÏà†Ï†ÅÏù¥Í≥† Ï†ÑÎ¨∏Ï†ÅÏù∏",
                "structure": "Ïù¥Î°†Ï†Å Î∞∞Í≤Ω, Í∑ºÍ±∞ Ï†úÏãú",
                "language": "ÌïôÏà† Ïö©Ïñ¥, Ï†ïÌôïÌïú ÌëúÌòÑ",
                "features": "ÎπÑÌåêÏ†Å ÏÇ¨Í≥†, ÍπäÏù¥ ÏûàÎäî Î∂ÑÏÑù"
            },
            "casual": {
                "tone": "Ìé∏ÏïàÌïòÍ≥† ÏπúÍ∑ºÌïú",
                "structure": "ÎåÄÌôîÏ≤¥, ÏûêÏó∞Ïä§Îü¨Ïö¥ ÌùêÎ¶Ñ",
                "language": "ÏùºÏÉÅÏ†Å ÌïúÍµ≠Ïñ¥",
                "features": "Í≥µÍ∞êÎåÄ ÌòïÏÑ±, Ïâ¨Ïö¥ Ïù¥Ìï¥"
            }
        }
        
        audience_context = {
            "university_students": "ÎåÄÌïôÏÉù ÏàòÏ§ÄÏùò Ïù¥Ìï¥ÎèÑÏôÄ Í¥ÄÏã¨ÏÇ¨Î•º Í≥†Î†§",
            "graduate_students": "ÎåÄÌïôÏõêÏÉù ÏàòÏ§ÄÏùò Ï†ÑÎ¨∏ÏÑ±Í≥º ÍπäÏù¥ ÏûàÎäî ÎÇ¥Ïö©",
            "professionals": "Ïã§Î¨¥ÏßÑÏùÑ ÏúÑÌïú Ïã§Ïö©Ï†ÅÏù¥Í≥† ÏùëÏö© Í∞ÄÎä•Ìïú ÎÇ¥Ïö©",
            "general_public": "ÏùºÎ∞òÏù∏ÎèÑ ÏâΩÍ≤å Ïù¥Ìï¥Ìï† Ïàò ÏûàÎäî ÎÇ¥Ïö©"
        }
        
        department_focus = {
            "Í∞ÑÌò∏ÌïôÍ≥º": "ÌôòÏûê ÏºÄÏñ¥, ÏûÑÏÉÅ Ïã§Ïäµ, Í∞ÑÌò∏ Ïú§Î¶¨, ÏùòÎ£åÏßÑ ÌòëÎ†•",
            "Î¨ºÎ¶¨ÏπòÎ£åÌïôÍ≥º": "Ïû¨ÌôúÏπòÎ£å, Ïö¥ÎèôÏπòÎ£å, ÌôòÏûê ÌèâÍ∞Ä, ÏπòÎ£å Í≥ÑÌöç",
            "ÏûëÏóÖÏπòÎ£åÌïôÍ≥º": "ÏùºÏÉÅÏÉùÌôú ÌöåÎ≥µ, Ïù∏ÏßÄÏû¨Ìôú, Î≥¥Ï°∞Í≥µÌïô, ÌôòÍ≤ΩÏ†ÅÏùë"
        }
        
        style_guide = style_guidelines.get(style_type, style_guidelines["educational"])
        audience_desc = audience_context.get(target_audience, audience_context["university_students"])
        dept_focus = department_focus.get(department, "Ï†ÑÍ≥µ Í¥ÄÎ†® Ï†ÑÎ¨∏ ÏßÄÏãù")
        
        system_prompt = f"""
ÎãπÏã†ÏùÄ {department} Ï†ÑÎ¨∏ ÍµêÏú° ÏΩòÌÖêÏ∏† Í∞úÏÑ† Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§.

=== Í∞úÏÑ† Î™©Ìëú ===
- Î¨∏Ï≤¥ Ïú†Ìòï: {style_type} ({style_guide['tone']})
- ÎåÄÏÉÅ ÎèÖÏûê: {target_audience} ({audience_desc})
- Ï†ÑÍ≥µ ÏòÅÏó≠: {dept_focus}

=== Í∞úÏÑ† Í∞ÄÏù¥ÎìúÎùºÏù∏ ===
1. ÌÜ§Ïï§Îß§ÎÑà: {style_guide['tone']}
2. Íµ¨ÏÑ± Î∞©Ïãù: {style_guide['structure']}
3. Ïñ∏Ïñ¥ Ïä§ÌÉÄÏùº: {style_guide['language']}
4. ÌäπÏßï: {style_guide['features']}

=== ÌïúÍµ≠Ïñ¥ Í∞úÏÑ† ÏöîÍµ¨ÏÇ¨Ìï≠ ===
- ÏûêÏó∞Ïä§ÎüΩÍ≥† Ï†ïÌôïÌïú ÌïúÍµ≠Ïñ¥ ÌëúÌòÑ
- Ï†ÑÎ¨∏ Ïö©Ïñ¥Ïùò Ï†ÅÏ†àÌïú ÏÇ¨Ïö©Í≥º ÏÑ§Î™Ö
- Î¨∏Ïû• Íµ¨Ï°∞Ïùò Î™ÖÌôïÏÑ±
- ÎèÖÏûê ÏπúÌôîÏ†Å ÌëúÌòÑ

=== Í∏àÏßÄ ÏÇ¨Ìï≠ ===
- ÏõêÎ≥∏ ÎÇ¥Ïö©Ïùò ÏùòÎØ∏ Î≥ÄÍ≤Ω Í∏àÏßÄ
- Ï§ëÏöîÌïú Ï†ÑÎ¨∏ Ïö©Ïñ¥ ÏûÑÏùò Î≥ÄÍ≤Ω Í∏àÏßÄ
- ÏÇ¨Ïã§ Ï†ïÎ≥¥ ÏôúÍ≥° Í∏àÏßÄ

Í∞úÏÑ†Îêú ÌÖçÏä§Ìä∏Îßå Ï∂úÎ†•ÌïòÍ≥† Ï∂îÍ∞Ä ÏÑ§Î™ÖÏùÄ ÌïòÏßÄ ÎßàÏÑ∏Ïöî.
"""
        
        user_prompt = f"""
Îã§Ïùå ÌÖçÏä§Ìä∏Î•º ÏúÑÏùò Í∞ÄÏù¥ÎìúÎùºÏù∏Ïóê Îî∞Îùº Í∞úÏÑ†Ìï¥Ï£ºÏÑ∏Ïöî:

{content}
"""
        
        return {
            "system": system_prompt,
            "user": user_prompt
        }
    
    async def _call_openai_api(self, messages: List[Dict[str, str]]) -> Dict[str, Any]:
        """OpenAI API Ìò∏Ï∂ú"""
        try:
            if self.client:  # ÏµúÏã† Î≤ÑÏ†Ñ
                response = await asyncio.to_thread(
                    self.client.chat.completions.create,
                    model=self.model_name,
                    messages=messages,
                    max_tokens=3000,
                    temperature=0.3
                )
                content = response.choices[0].message.content
            else:  # Íµ¨Î≤ÑÏ†Ñ Ìò∏Ìôò
                response = await asyncio.to_thread(
                    openai.ChatCompletion.create,
                    model=self.model_name,
                    messages=messages,
                    max_tokens=3000,
                    temperature=0.3
                )
                content = response.choices[0].message.content
            
            return {
                "success": True,
                "content": content
            }
            
        except Exception as e:
            logger.error(f"OpenAI API Ìò∏Ï∂ú Ïò§Î•ò: {e}")
            return {
                "success": False,
                "error": str(e),
                "content": ""
            }
    
    def _analyze_improvement(
        self, 
        original: str, 
        improved: str, 
        style_type: str
    ) -> Dict[str, Any]:
        """Í∞úÏÑ† Í≤∞Í≥º Î∂ÑÏÑù"""
        return {
            "original_length": len(original),
            "improved_length": len(improved),
            "length_change_ratio": len(improved) / len(original) if original else 1.0,
            "style_applied": style_type,
            "improvement_metrics": {
                "readability": "improved",
                "clarity": "enhanced",
                "professionalism": "maintained"
            }
        }
    
    async def _fallback_text_improvement(
        self, 
        content: str, 
        style_type: str
    ) -> Dict[str, Any]:
        """OpenAI ÏÇ¨Ïö© Î∂àÍ∞ÄÏãú ÎåÄÏ≤¥ ÌÖçÏä§Ìä∏ Í∞úÏÑ†"""
        logger.info("OpenAI ÏÇ¨Ïö© Î∂àÍ∞Ä - Í∏∞Î≥∏ ÌÖçÏä§Ìä∏ Í∞úÏÑ† Ï†ÅÏö©")
        
        # Í∏∞Î≥∏Ï†ÅÏù∏ ÌÖçÏä§Ìä∏ Ï†ïÎ¶¨
        improved_content = content.strip()
        
        # Í∞ÑÎã®Ìïú Í∞úÏÑ† ÏûëÏóÖ
        if style_type == "educational":
            # ÍµêÏú°Ï†Å Ïä§ÌÉÄÏùº: Î¨∏Ïû• ÎÅùÏùÑ Ï†ïÏ§ëÌïòÍ≤å
            improved_content = improved_content.replace("Îã§.", "Îã§Í≥† Ìï† Ïàò ÏûàÏäµÎãàÎã§.")
        elif style_type == "formal":
            # Í≤©ÏãùÏ†Å Ïä§ÌÉÄÏùº: Ï°¥ÎåìÎßê Í∞ïÌôî
            improved_content = improved_content.replace("Ìï¥Ïöî.", "Ìï©ÎãàÎã§.")
        
        return {
            "success": True,
            "improved_content": improved_content,
            "original_content": content,
            "improvement_analysis": {
                "method": "fallback_basic_improvement",
                "original_length": len(content),
                "improved_length": len(improved_content)
            },
            "style_type": style_type,
            "fallback_used": True,
            "improved_at": datetime.now().isoformat()
        }
    
    def _is_openai_available(self) -> bool:
        """OpenAI ÏÇ¨Ïö© Í∞ÄÎä• Ïó¨Î∂Ä ÌôïÏù∏"""
        return OPENAI_AVAILABLE and self.api_key and (self.client or openai)

# Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
openai_service = OpenAIService()    